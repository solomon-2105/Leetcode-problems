1) sort characters by their frequencies

class Solution {
public:
    string frequencySort(string s) {
        vector<int> fr(128,0);
        for(char c:s){
            fr[c]++;
        }
        vector<pair<char,int>>vec;
        for(int i=0;i<128;i++){
            if(fr[i]>0) vec.push_back({(char)i,fr[i]});
        }
        sort(vec.begin(),vec.end(),compare);
        string res="";
        for(auto p:vec){
            res.append(p.second,p.first);
        }
        return res;
    }
    static bool compare(pair<char,int> &a,pair<char,int> &b){
        return a.second>b.second;
    }
};


2)Roman numeral to Integer conversion 

class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char,int> u={{'I',1},{'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000}};
        int count=0;
        for(int i=0;i<s.size();i++){
            if(((i+1)<s.size()) && (u[s[i]]<u[s[i+1]])){
                count-=u[s[i]];
            }
            else{
                count+=u[s[i]];
            }
        }
        return count;
    }
};


3) Integer to Roman Numeral conversion

class Solution {
public:
    string intToRoman(int num) {
        vector<pair<int,string>> brr={
            {1000,"M"},
            {900,"CM"},
            {500,"D"},
            {400,"CD"},
            {100,"C"},
            {90,"XC"},
            {50,"L"},
            {40,"XL"},
            {10,"X"},
            {9,"IX"},
            {5,"V"},
            {4,"IV"},
            {1,"I"}
        };
        string res="";
        for(auto &c: brr){
            while(num>=c.first){
                res+=c.second;
                num-=c.first;
            }
        }
        return res;
    }
};


4)Longest palindromic substring (bruteforce)

class Solution:
    def longestPalindrome(self, s: str) -> str:
        maxlen=float('-inf')
        sp=0
        n=len(s)
        for i in range(n):
            for j in range(i,n):
                if self.palindrome(s,i,j):
                    if maxlen<(j-i+1):
                        maxlen=j-i+1
                        sp=i
        return s[sp:sp+maxlen]
    
    def palindrome(self,s:str,i:int,j:int)->bool:
        l,h=i,j
        while l<=h:
            if s[l]!=s[h]: return False
            else:
                l+=1
                h-=1
        return True


5)longest palindromic substring (2 pointers approach)

class Solution:
    def longestPalindrome(self, s: str) -> str:
        n=len(s)
        maxlen=float('-inf')
        sp=0
        for i in range(len(s)):
            l,r=self.brr(s,i,i)
            if r-l+1>maxlen:
                maxlen=r-l+1
                sp=l
            l,r=self.brr(s,i,i+1)
            if r-l+1>maxlen:
                maxlen=r-l+1
                sp=l
        return s[sp:sp+maxlen]
    
    def brr(self,s,l,r):
        while l>=0 and r<len(s) and s[l]==s[r]:
            l-=1
            r+=1
        return l+1,r-1


6) Reverse the words in a string 

class Solution:
    def reverseWords(self, s: str) -> str:
        def reversee(brr,left,right):
            while left<=right:
                brr[left],brr[right]=brr[right],brr[left]
                left+=1
                right-=1
        brr=list(s.strip())
        reversee(brr,0,len(brr)-1)
        i=k=0
        res=[]
        while k<len(brr):
            if brr[k]!=" ":
                k+=1
            else:
                reversee(brr,i,k-1)
                res.append("".join(brr[i:k]))
                while k<len(brr) and brr[k]==" ":
                    k+=1
                i=k
        reversee(brr,i,len(brr)-1)
        res.append("".join(brr[i:]))
        return " ".join(res)


7) Count no of homogenous substrings (bruteforce)

class Solution:
    def countHomogenous(self, s: str) -> int:
        count=0
        n=len(s)
        for i in range(n):
            for j in range(i,n):
                if self.homo(s[i:j+1]):
                    count+=1
        return count
    
    def homo(self,p)->bool :
        a=set()
        for i in p:
            a.add(i)
        return len(a)==1


8) count no of homogenous substrings (Run length Encoding inspired Counting technique)

class Solution:
    def countHomogenous(self, s: str) -> int:
        MOD=10**9+7
        count=0
        n=len(s)
        i=0
        while i<n:
            char=s[i]
            length=0
            while i<n and s[i]==char:
                i+=1
                length+=1
            count=count+ (length*(length+1)//2)
            count%=MOD
        return count


9) Maximum Nesting Depth of Paranthesis

class Solution:
    def maxDepth(self, s: str) -> int:
        maxl,c=0,0
        for i in s:
            if i=="(":
                c+=1
                maxl=max(maxl,c)
            elif i==")":
                c-=1
        return maxl


10) Sum of Beauty of all substring (optimal , bruteforce can be woven from it)

class Solution:
    def beautySum(self, s: str) -> int:
        count=0
        n=len(s)
        for i in range(n):
            brr={}
            for j in range(i,n):
                brr[s[j]]=brr.get(s[j],0)+1
                values=brr.values()
                maxi=max(values)
                mini=min(values)
                count+=(maxi-mini)
        return count