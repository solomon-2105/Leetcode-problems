1)combinations

n=int(input("Enter the number of items (n): "))
r=int(input("Enter the number of items to choose (r): "))
res=1
for i in range(r):
    res=res*(n-i)
    res=res//(i+1)
print("Number of combinations:", res)


2)nth row of pascal's triangle

n=int(input("Enter the row number (n): "))
res=1
brr=[1]
for i in range(1,n+1):
    if i==n:
        brr.append(1)
    else:
        res=res*(n-i+1)//i
        brr.append(res)
print("The nth row of Pascal's triangle:", brr) 


3)nth row of pascal's triangle (bruteforce) (using previously calculated values by using ncr formula) 

n=int(input("Enter the row number (n): "))
res=1
print(1,end=" ")
for i in range(1,n):
    res=res*(n-i)
    res=res//i
    print(res, end=' ')


4)pascal triangle

n=int(input("Enter the number of rows (n): "))
for i in range(n):
    res=1
    print(res,end=" ")
    for j in range(1,i+1):
        res=res*(i-j+1)//j
        print(res,end=" ")
    print() 


5)pascal triangle (Dynamic programming)

n=int(input("Enter the number of rows (n): "))
a=[[1]*(i+1) for i in range(n)]
for i in range(2,n):
    for j in range(1,i):
        a[i][j]=a[i-1][j-1]+a[i-1][j]
print(a)


6)majority element (n/3 times)

a=[1,1,1,3,2,2,2,3]
n=len(a)
br=[]
for i in range(n):
    if len(br)==0 or br[0]!=a[i]:
        cnt=0
        for j in range(n):
            if a[i]==a[j]:
                cnt+=1
        if cnt>n//3:
            br.append(a[i])
    if len(br)==2:
        break
print("Majority elements (more than n/3 times):", br)


7)majority element (n/3 times) (hashmap , better)

a=[1,1,1,3,2,2,2,3]
n=len(a)
br={}
for i in range(n):
    if a[i] in br:
        br[a[i]] += 1
    else:
        br[a[i]] = 1
sa=[]
for c,d in br.items():
    if d>n//3:
        sa.append(c)
print("Majority elements (more than n/3 times):", sa)


8)majority element (n/3 times) (Booyer moore's voting algorithm , optimal)

import math
a=[1,1,1,3,2,2,2,3]
count1,count2,n=0,0,len(a)
el1,el2=None,None
for i in range(n):
    if count1==0 and a[i]!=el2:
        count1=1
        el1=a[i]
    elif count2==0 and a[i]!=el1:
        count2=1
        el2=a[i]
    elif el1==a[i]:
        count1+=1
    elif el2==a[i]:
        count2+=1
    else:
        count1-=1
        count2-=1
brr,grr=0,0
for i in a:
    if el1==i:
        brr+=1
    elif el2==i:
        grr+=1
an=[]
crr=math.floor(n/3)
if brr>crr:
    an.append(el1)
if grr>crr:
    an.append(el2)
print(an)



9)3sum - bruteforce

class Solution:
    def threeSum(self, a: List[int]) -> List[List[int]]:
        aaha=set() #bruteforce
        for i in range(len(a)):
            for j in range(i+1,len(a)):
                for k in range(j+1,len(a)):
                    if a[i]+a[j]+a[k]==0:
                        brr=[a[i],a[j],a[k]]
                        brr.sort()
                        aaha.add(tuple(brr))
        d=[list(i) for i in aaha]
        return d


        10)better solution

        drr=set()
        for i in range(len(a)):
            brr=set()
            for j in range(i+1,len(a)):
                grr=-(a[i]+a[j])
                if grr in brr:
                    drr.add(tuple(sorted([a[i],a[j],grr])))
                brr.add(a[j])
        crr=[list(i) for i in drr]
        return crr


        11)two pointers (optimal)
        
        brr=list()
        a.sort()
        for i in range(len(a)):
            if i>0 and a[i]==a[i-1]: continue
            j=i+1
            k=len(a)-1
            while j<k:
                summ=a[i]+a[j]+a[k]
                if summ<0:
                    j+=1
                elif summ>0:
                    k-=1
                else:
                    ass=[a[i],a[j],a[k]]
                    brr.append(ass)
                    j+=1
                    k-=1
                    while j<k and a[j]==a[j-1]: j+=1
                    while j<k and a[k]==a[k+1]: k-=1
        return brr



12)Maximum product subarray
bruteforce

import sys
a=[2,3,-2,4]
maxi=-sys.maxsize
for i in range(len(a)):
    prod=1
    for j in range(i,len(a)):
        prod*=a[j]
        maxi=max(maxi,prod)
print(f"maximum product of the subarrays is {maxi} ")


13)maximum product subarray(optimal)

import sys
a=list(map(int,input().split()))
maxi=-sys.maxsize
prefix=suffix=1
for i in range(len(a)):
    if a[i]==0:
        prefix=1
        continue
    prefix*=a[i]
    maxi=max(maxi,prefix)
for i in range(len(a)-1,-1,-1):
    if a[i]==0:
        suffix=1
        continue
    suffix*=a[i]
    maxi=max(maxi,suffix)
print(maxi)


14)longest subarray with sum 0
bruteforce is by generating all subarrays and finding the ones which have the sum as 0 and finding their length


15)longest subarray with sum 0 - optimal (prefix sum + hashmap approach)

import sys
a=list(map(int,input().split()))
brr={0:-1}
maxi=-sys.maxsize
presum=0
for i in range(len(a)):
    presum+=a[i]
    if presum in brr:
        maxi=max(maxi,i-brr[presum])
    if presum not in brr:
        brr[presum]=i
print(f"length of the longest subarray with 0 sum is {maxi}")


16)count inversions (bruteforce)

a=list(map(int,input().split()))
count=0
for i in range(len(a)):
        for j in range(i+1,len(a)):
                if a[i]>a[j]:
                        count+=1
print(count)

17)count inversions - optimal approach(using merge sort)

def merge(a,low,mid,high):
    m=mid-low+1
    n=high-mid
    brr=[0]*m
    grr=[0]*n
    for i in range(m):
        brr[i]=a[low+i]
    for j in range(n):
        grr[j]=a[mid+j+1]
    i,j,huh,inv=0,0,low,0
    while i<m and j<n:
        if brr[i]<=grr[j]:
            a[huh]=brr[i]
            i+=1
        else:
            a[huh]=grr[j]
            j+=1
            inv+=m-i
        huh+=1
    while i<m:
        a[huh]=brr[i]
        i+=1
        huh+=1
    while j<n:
        a[huh]=grr[j]
        j+=1
        huh+=1
    return inv    

def merge_sort(a,low,high):
    inv=0
    if low<high:
        mid=low+(high-low)//2
        inv+=merge_sort(a,low,mid)
        inv+=merge_sort(a,mid+1,high)
        inv+=merge(a,low,mid,high)
    return inv

if __name__=="__main__":
    a=list(map(int,input().split()))
    inv=merge_sort(a,0,len(a)-1)
    print(f"no of inversions are : {inv}")


18)Reverse Pairs (bruteforce)

a=list(map(int,input().split()))
cnt=0
for i in range(len(a)):
        for j in range(i+1,len(a)):
                if a[i]>2*a[j]:
                      cnt+=1
print(f"no of reverse pairs are {cnt}")


19)reverse pairs - optimal (merge sort based approach)

count=0
def merge(a,low,mid,high):
    m=mid-low+1
    n=high-mid
    brr=[0]*m
    grr=[0]*n
    for i in range(m):
        brr[i]=a[low+i]
    for j in range(n):
        grr[j]=a[mid+j+1]
    i,j,huh=0,0,low
    while i<m and j<n:
        if brr[i]<=grr[j]:
            a[huh]=brr[i]
            i+=1
        else:
            a[huh]=grr[j]
            j+=1
        huh+=1
    while i<m:
        a[huh]=brr[i]
        i+=1
        huh+=1
    while j<n:
        a[huh]=grr[j]
        j+=1
        huh+=1

def count_pairs(a,low,mid,high):
    global count
    right=mid+1
    for i in range(low,mid+1):
        while right<=high and a[i]>2*a[right]:
            right+=1
        count=count+(right-(mid+1))

def merge_sort(a,low,high):
    if low<high:
        mid=low+(high-low)//2
        merge_sort(a,low,mid)
        merge_sort(a,mid+1,high)
        count_pairs(a,low,mid,high)
        merge(a,low,mid,high)

if __name__=="__main__":
    a=list(map(int,input().split()))
    merge_sort(a,0,len(a)-1)
    print(f"no of reverse pairs are : {count}")